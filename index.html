<!DOCTYPE html>
<html lang="es">

<head>
  <meta charset="UTF-8" />
  <title>Mini Juego 2D - Esquiva los bloques</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      min-height: 100vh;
      margin: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #101020, #05010a 60%);
      color: #e5e7eb;
    }

    .game-wrapper {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 10px;
    }

    h1 {
      font-size: 20px;
      text-align: center;
    }

    #gameCanvas {
  width: 100%;
  max-width: 900px;
  max-height: 80vh;        /* altura normal en desktop */
  aspect-ratio: 9 / 16;
  border-radius: 18px;
  border: 1px solid rgba(129, 140, 248, 0.6);
  background: radial-gradient(circle at center, #050510, #020008 70%);
  box-shadow: 0 20px 45px rgba(0, 0, 0, 0.9);
  display: block;
}


    .info {
      font-size: 14px;
      text-align: center;
      opacity: 0.8;
    }

    .info span {
      font-weight: bold;
    }

    /* Controles m√≥viles (solo se muestran en dispositivos t√°ctiles) */
    .mobile-controls {
      margin-top: 8px;
      display: none;
      gap: 16px;
      width: 100%;
      justify-content: space-between;
    }

    .mobile-controls button {
      flex: 1;
      padding: 12px 0;
      font-size: 20px;
      border: none;
      border-radius: 999px;
      background: radial-gradient(circle at top, #1e293b, #020617);
      color: #e5e7eb;
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
      touch-action: none;
    }

    .mobile-controls button:active {
      transform: scale(0.97) translateY(1px);
    }

    body.is-touch .mobile-controls {
      display: flex;
    }

    /* üì± Ajustes para pantallas peque√±as (m√≥vil) */
@media (max-width: 768px) {

  body {
    align-items: flex-start;
  }

  .game-wrapper {
    max-width: 100%;
    padding: 0;
    margin-top: 8px;
  }

  /* Canvas m√°s grande en m√≥vil */
  #gameCanvas {
    max-height: 90vh;   /* antes 80vh ‚Üí ahora usa m√°s pantalla */
    border-radius: 12px;
  }

  /* Ajustes de controles m√≥viles */
  .mobile-controls {
    gap: 12px;
    margin-top: 10px;
  }

  .mobile-controls button {
    padding: 18px 0;     /* m√°s altos */
    font-size: 26px;     /* iconos m√°s grandes */
  }
}

  </style>
</head>

<body>
  <div class="game-wrapper">
    <h1>üéÆ Esquiva los bloques</h1>
    <canvas id="gameCanvas" width="480" height="640"></canvas>

    <!-- Controles m√≥viles (aparecen solo si hay pantalla t√°ctil) -->
    <div class="mobile-controls">
      <button id="btnLeft">‚óÄ</button>
      <button id="btnRight">‚ñ∂</button>
    </div>

    <div class="info">
      Controles: <span>‚óÄÔ∏è ‚ñ∂Ô∏è</span> para moverte &nbsp;|&nbsp;
      <span>Espacio</span> para reiniciar &nbsp;|&nbsp;
      <span>H</span> Modo Hardcore
    </div>
  </div>

  <script>
    const canvas = document.getElementById("gameCanvas");
    const ctx = canvas.getContext("2d");

    // --- CONFIGURACI√ìN DEL JUEGO ---
    const player = {
      x: canvas.width / 2 - 25,
      y: canvas.height - 60,
      width: 50,
      height: 20,
      speed: 6
    };

    let obstacles = [];
    let powerups = [];
    let lastObstacleTime = 0;
    let obstacleInterval = 900; // ms entre spawns, se ir√° reduciendo
    const BASE_OBSTACLE_INTERVAL = 900;
    const MIN_OBSTACLE_INTERVAL = 400;

    let powerupTimer = 0;
    const POWERUP_INTERVAL = 8000;

    let isGameOver = false;
    let score = 0;
    let bestScore = 0;
    let lastTime = 0;

    const BEST_SCORE_KEY = "dodge_best_score_v1";

    const keys = {
      ArrowLeft: false,
      ArrowRight: false
    };

    // --- DETECCI√ìN DE DISPOSITIVO T√ÅCTIL Y CONTROLES M√ìVILES ---
    const isTouchDevice =
      ("ontouchstart" in window) ||
      (navigator.maxTouchPoints > 0) ||
      (window.matchMedia && window.matchMedia("(pointer: coarse)").matches);

    if (isTouchDevice) {
      document.body.classList.add("is-touch");

      const btnLeft = document.getElementById("btnLeft");
      const btnRight = document.getElementById("btnRight");

      const pressLeft = (e) => {
        e.preventDefault();
        keys.ArrowLeft = true;
      };
      const releaseLeft = (e) => {
        e.preventDefault();
        keys.ArrowLeft = false;
      };

      const pressRight = (e) => {
        e.preventDefault();
        keys.ArrowRight = true;
      };
      const releaseRight = (e) => {
        e.preventDefault();
        keys.ArrowRight = false;
      };

      // Eventos t√°ctiles
      btnLeft.addEventListener("touchstart", pressLeft);
      btnLeft.addEventListener("touchend", releaseLeft);
      btnLeft.addEventListener("touchcancel", releaseLeft);

      btnRight.addEventListener("touchstart", pressRight);
      btnRight.addEventListener("touchend", releaseRight);
      btnRight.addEventListener("touchcancel", releaseRight);

      // Opcional: tambi√©n permitir click con mouse (por si se usa en tablet con mouse)
      btnLeft.addEventListener("mousedown", pressLeft);
      btnLeft.addEventListener("mouseup", releaseLeft);
      btnLeft.addEventListener("mouseleave", releaseLeft);

      btnRight.addEventListener("mousedown", pressRight);
      btnRight.addEventListener("mouseup", releaseRight);
      btnRight.addEventListener("mouseleave", releaseRight);

        // --- Control t√°ctil directo sobre el canvas ---
  const handleCanvasTouch = (e) => {
    e.preventDefault();
    const touch = e.touches[0];
    if (!touch) return;

    const rect = canvas.getBoundingClientRect();
    const x = touch.clientX - rect.left;

    const middle = rect.width / 2;

    // Reseteamos primero
    keys.ArrowLeft = false;
    keys.ArrowRight = false;

    if (x < middle) {
      keys.ArrowLeft = true;
    } else {
      keys.ArrowRight = true;
    }
  };

  const handleCanvasTouchEnd = (e) => {
    e.preventDefault();
    keys.ArrowLeft = false;
    keys.ArrowRight = false;
  };

  canvas.addEventListener("touchstart", handleCanvasTouch);
  canvas.addEventListener("touchmove", handleCanvasTouch);
  canvas.addEventListener("touchend", handleCanvasTouchEnd);
  canvas.addEventListener("touchcancel", handleCanvasTouchEnd);

    }

    // --- EFECTOS extra ---
    let screenShake = 0;
    const streaks = [];      // l√≠neas r√°pidas tipo F-Zero en roz√≥n
    const particles = [];    // part√≠culas cuando un bloque desaparece
    const playerTrail = [];  // afterimage del jugador
    const comboTexts = [];   // textos flotantes de combo

    let combo = 0;
    let bestCombo = 0;
    let lastNearMissTime = 0;
    const NEAR_MISS_DISTANCE = 50;

    let slowMotionActive = false;
    let slowMotionTimer = 0;

    let shieldActive = false;
    let shieldTimer = 0;

    let hardcoreActive = false;

    // Niveles
    let level = 1;
    const LEVEL_UP_SCORE = 400; // puntos para subir de nivel
    let nextLevelScore = LEVEL_UP_SCORE;
    let levelUpFlashTimer = 0; // ms para flash de nivel

    // --- SONIDOS ---
    const sfxNearMiss = new Audio("./Sounds/sfx_near_miss.mp3");
    sfxNearMiss.volume = 0.4;

    const sfxGameOver = new Audio("./Sounds/sfx_game_over.mp3");
    sfxGameOver.volume = 0.6;

    const sfxBlockPass = new Audio("./Sounds/sfx_blip.mp3");
    sfxBlockPass.volume = 0.3;

    const sfxPowerup = new Audio("./Sounds/sfx_powerup.mp3");
    sfxPowerup.volume = 0.5;

    const sfxShieldHit = new Audio("./Sounds/sfx_shield_hit.mp3");
    sfxShieldHit.volume = 0.5;

    // Hum / ambiente del escudo (loop)
    const sfxShieldHum = new Audio("./Sounds/sfx_shield_hum.mp3");
    sfxShieldHum.volume = 0.18;
    sfxShieldHum.loop = true;

    // Cargar mejor puntaje si existe
    (function loadBestScore() {
      try {
        const stored = localStorage.getItem(BEST_SCORE_KEY);
        if (stored) bestScore = parseFloat(stored) || 0;
      } catch (e) {
        bestScore = 0;
      }
    })();

    // --- INPUT TECLADO ---
    window.addEventListener("keydown", (e) => {
      if (e.code === "ArrowLeft" || e.code === "ArrowRight") {
        keys[e.code] = true;
      }

      if (e.code === "Space" && isGameOver) {
        restartGame();
      }

      if (e.code === "KeyH" && !isGameOver) {
        hardcoreActive = !hardcoreActive;
        screenShake = 8;
        comboTexts.push({
          x: canvas.width / 2,
          y: canvas.height / 2 - 80,
          text: hardcoreActive ? "HARDCORE ON" : "HARDCORE OFF",
          life: 800,
          color: hardcoreActive ? "#f97316" : "#38bdf8"
        });
      }
    });

    window.addEventListener("keyup", (e) => {
      if (e.code === "ArrowLeft" || e.code === "ArrowRight") {
        keys[e.code] = false;
      }
    });

    // --- FUNCIONES PRINCIPALES ---
    function restartGame() {
      obstacles = [];
      powerups = [];
      isGameOver = false;
      score = 0;
      lastObstacleTime = 0;
      obstacleInterval = BASE_OBSTACLE_INTERVAL;
      player.x = canvas.width / 2 - player.width / 2;

      screenShake = 0;
      streaks.length = 0;
      particles.length = 0;
      playerTrail.length = 0;
      comboTexts.length = 0;

      combo = 0;
      lastNearMissTime = 0;
      slowMotionActive = false;
      slowMotionTimer = 0;
      shieldActive = false;
      shieldTimer = 0;
      hardcoreActive = false;

      level = 1;
      nextLevelScore = LEVEL_UP_SCORE;
      levelUpFlashTimer = 0;

      try {
        sfxShieldHum.pause();
        sfxShieldHum.currentTime = 0;
      } catch (e) { }
    }

    function spawnObstacle() {
      let width = 40 + Math.random() * 40;
      let height = 20 + Math.random() * 20;
      const x = Math.random() * (canvas.width - width);
      let speed = 2 + Math.random() * 3;

      // Tipo de bloque: normal, dorado (bonus), peligro (rojo)
      let type = "normal";
      const r = Math.random();
      if (r > 0.9) {
        type = "gold"; // ~10%
        width *= 0.8;
        height *= 0.8;
        speed += 1.5;
      } else if (r < 0.15) {
        type = "danger"; // ~15%
        width *= 1.3;
        height *= 1.1;
        speed -= 0.5;
      }

      // Aumentar un poco la velocidad base seg√∫n el nivel
      speed += (level - 1) * 0.2;

      obstacles.push({
        x,
        y: -50,
        width,
        height,
        speed,
        type
      });
    }

    function spawnBlockParticles(obstacle, colorOverride) {
      const cx = obstacle.x + obstacle.width / 2;
      const cy = obstacle.y + obstacle.height / 2;
      const color = colorOverride || "#FFE600";

      for (let i = 0; i < 12; i++) {
        particles.push({
          x: cx,
          y: cy,
          vx: (Math.random() - 0.5) * 3,
          vy: (Math.random() - 1.2) * 3,
          life: 300 + Math.random() * 200,
          radius: 2 + Math.random() * 2,
          color
        });
      }
    }

    function spawnPowerup() {
      const type = Math.random() < 0.5 ? "slow" : "shield";
      const size = 26;
      const x = Math.random() * (canvas.width - size);
      const speed = 2 + Math.random() * 2;

      powerups.push({
        x,
        y: -size,
        width: size,
        height: size,
        speed,
        type
      });
    }

    function update(deltaTime) {
      if (isGameOver) return;

      const levelSpeed = 1 + (level - 1) * 0.08;
      const speedFactor =
        (slowMotionActive ? 0.4 : 1) *
        (hardcoreActive ? 1.5 : 1) *
        levelSpeed;

      const scoreMultiplier = hardcoreActive ? 2 : 1;

      // Actualizar jugador
      if (keys.ArrowLeft) {
        player.x -= player.speed;
      }
      if (keys.ArrowRight) {
        player.x += player.speed;
      }

      // Limites
      if (player.x < 0) player.x = 0;
      if (player.x + player.width > canvas.width)
        player.x = canvas.width - player.width;

      // Trail del jugador (afterimage)
      playerTrail.push({
        x: player.x,
        y: player.y,
        width: player.width,
        height: player.height,
        life: 200
      });
      playerTrail.forEach(t => {
        t.life -= deltaTime;
      });
      for (let i = playerTrail.length - 1; i >= 0; i--) {
        if (playerTrail[i].life <= 0) playerTrail.splice(i, 1);
      }

      // Spawnear obst√°culos
      lastObstacleTime += deltaTime;
      const intervalFactor = hardcoreActive ? 0.8 : 1;
      if (lastObstacleTime > obstacleInterval * intervalFactor) {
        spawnObstacle();
        lastObstacleTime = 0;

        if (obstacleInterval > MIN_OBSTACLE_INTERVAL) {
          obstacleInterval -= 10;
        }
      }

      // Power-ups
      powerupTimer += deltaTime;
      if (powerupTimer > POWERUP_INTERVAL) {
        spawnPowerup();
        powerupTimer = 0;
      }

      // Actualizar obst√°culos + roz√≥n + part√≠culas
      obstacles.forEach(o => {
        o.y += o.speed * speedFactor;

        const playerBottom = player.y + player.height;
        const obstacleBottom = o.y + o.height;

        const horizontalOverlap =
          o.x < player.x + player.width &&
          o.x + o.width > player.x;

        const isNearVertically =
          obstacleBottom >= player.y - NEAR_MISS_DISTANCE &&
          obstacleBottom <= playerBottom + NEAR_MISS_DISTANCE;

        if (
          !isGameOver &&
          horizontalOverlap &&
          isNearVertically &&
          !o._nearMissTriggered
        ) {
          o._nearMissTriggered = true;

          screenShake = Math.max(screenShake, 6);

          streaks.push({
            x: player.x + player.width / 2,
            y: player.y + player.height / 2,
            vx: (Math.random() - 0.5) * 5,
            vy: -8,
            life: 200
          });

          combo++;
          lastNearMissTime = 0;
          if (combo > bestCombo) bestCombo = combo;

          comboTexts.push({
            x: player.x + player.width / 2,
            y: player.y - 10,
            text: "x" + combo,
            life: 800,
            color: "#e5e7eb"
          });

          try {
            sfxNearMiss.currentTime = 0;
            sfxNearMiss.play();
          } catch (e) { }
        }

        if (o.y > canvas.height && !o._remove) {
          o._remove = true;

          let pColor = "#FFE600";
          if (o.type === "danger") pColor = "#f97316";
          if (o.type === "gold") pColor = "#facc15";

          spawnBlockParticles(o, pColor);

          if (o.type === "gold") {
            score += 50;
            comboTexts.push({
              x: o.x + o.width / 2,
              y: canvas.height - 80,
              text: "+50",
              life: 700,
              color: "#facc15"
            });
          }

          try {
            sfxBlockPass.currentTime = 0;
            sfxBlockPass.play();
          } catch (e) { }
        }
      });

      obstacles = obstacles.filter(o => !o._remove && o.y < canvas.height + 80);

      // Actualizar power-ups
      powerups.forEach(p => {
        p.y += p.speed * (slowMotionActive ? 0.5 : 0.9);
      });

      powerups.forEach(p => {
        if (!p._taken && isColliding(player, p)) {
          p._taken = true;
          if (p.type === "slow") {
            slowMotionActive = true;
            slowMotionTimer = 3500;
            comboTexts.push({
              x: player.x + player.width / 2,
              y: player.y - 30,
              text: "SLOW MOTION",
              life: 900,
              color: "#38bdf8"
            });
          } else if (p.type === "shield") {
            shieldActive = true;
            shieldTimer = 16000;
            comboTexts.push({
              x: player.x + player.width / 2,
              y: player.y - 30,
              text: "ESCUDO ACTIVADO",
              life: 900,
              color: "#34d399"
            });
            try {
              sfxShieldHum.currentTime = 0;
              sfxShieldHum.play();
            } catch (e) { }
          }
          try {
            sfxPowerup.currentTime = 0;
            sfxPowerup.play();
          } catch (e) { }
        }
      });
      powerups = powerups.filter(p => !p._taken && p.y < canvas.height + 40);

      // Colisiones con obst√°culos
      for (const o of obstacles) {
        if (isColliding(player, o)) {
          if (shieldActive) {
            shieldActive = false;
            shieldTimer = 0;
            o._remove = true;
            spawnBlockParticles(o, "#34d399");
            screenShake = 10;
            try {
              sfxShieldHit.currentTime = 0;
              sfxShieldHit.play();
              sfxShieldHum.pause();
              sfxShieldHum.currentTime = 0;
            } catch (e) { }
          } else {
            isGameOver = true;
            combo = 0;
            try {
              sfxGameOver.currentTime = 0;
              sfxGameOver.play();
              sfxShieldHum.pause();
              sfxShieldHum.currentTime = 0;
            } catch (e) { }

            if (score > bestScore) {
              bestScore = score;
              try {
                localStorage.setItem(BEST_SCORE_KEY, bestScore.toString());
              } catch (e) { }
            }
            break;
          }
        }
      }

      // Score
      score += deltaTime * 0.01 * scoreMultiplier;

      // Niveles
      if (!isGameOver && score >= nextLevelScore) {
        level++;
        nextLevelScore = level * LEVEL_UP_SCORE;
        levelUpFlashTimer = 600;
        screenShake = Math.max(screenShake, 10);
        comboTexts.push({
          x: canvas.width / 2,
          y: 120,
          text: "Nivel " + level,
          life: 1000,
          color: "#a5b4fc"
        });
      }

      if (levelUpFlashTimer > 0) {
        levelUpFlashTimer -= deltaTime;
        if (levelUpFlashTimer < 0) levelUpFlashTimer = 0;
      }

      // Streaks
      streaks.forEach(s => {
        s.x += s.vx;
        s.y += s.vy;
        s.life -= deltaTime;
      });
      for (let i = streaks.length - 1; i >= 0; i--) {
        if (streaks[i].life <= 0) streaks.splice(i, 1);
      }

      // Part√≠culas
      particles.forEach(p => {
        p.x += p.vx;
        p.y += p.vy;
        p.life -= deltaTime;
      });
      for (let i = particles.length - 1; i >= 0; i--) {
        if (particles[i].life <= 0) particles.splice(i, 1);
      }

      // Textos flotantes
      comboTexts.forEach(t => {
        t.y -= 0.04 * deltaTime;
        t.life -= deltaTime;
      });
      for (let i = comboTexts.length - 1; i >= 0; i--) {
        if (comboTexts[i].life <= 0) comboTexts.splice(i, 1);
      }

      // Timers
      if (slowMotionActive) {
        slowMotionTimer -= deltaTime;
        if (slowMotionTimer <= 0) {
          slowMotionActive = false;
        }
      }

      if (shieldActive) {
        shieldTimer -= deltaTime;
        if (shieldTimer <= 0) {
          shieldActive = false;
          try {
            sfxShieldHum.pause();
            sfxShieldHum.currentTime = 0;
          } catch (e) { }
        }
      }

      lastNearMissTime += deltaTime;
      if (lastNearMissTime > 3000 && combo > 0) {
        combo = 0;
        lastNearMissTime = 0;
      }
    }

    function isColliding(a, b) {
      return (
        a.x < b.x + b.width &&
        a.x + a.width > b.x &&
        a.y < b.y + b.height &&
        a.y + a.height > b.y
      );
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      ctx.save();
      if (screenShake > 0) {
        const dx = (Math.random() - 0.5) * screenShake;
        const dy = (Math.random() - 0.5) * screenShake;
        ctx.translate(dx, dy);

        screenShake *= 0.9;
        if (screenShake < 0.3) screenShake = 0;
      }

      const width = canvas.width;
      const height = canvas.height;

      const bgGradient = ctx.createLinearGradient(0, 0, 0, height);
      bgGradient.addColorStop(0, "#05010a");
      bgGradient.addColorStop(0.4, "#090921");
      bgGradient.addColorStop(1, "#05010a");
      ctx.fillStyle = bgGradient;
      ctx.fillRect(0, 0, width, height);

      ctx.save();
      ctx.globalAlpha = 0.08;
      ctx.fillStyle = "#1f2937";
      for (let y = 0; y < height; y += 8) {
        ctx.fillRect(0, y, width, 1);
      }
      ctx.restore();

      ctx.fillStyle = "rgba(255,255,255,0.14)";
      for (let i = 0; i < 40; i++) {
        const x = (i * 37) % width;
        const y = (i * 97) % height;
        ctx.fillRect(x, y, 2, 2);
      }

      if (shieldActive) {
        ctx.save();
        ctx.fillStyle = "rgba(34,197,94,0.06)";
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      if (slowMotionActive) {
        ctx.save();
        ctx.fillStyle = "rgba(56,189,248,0.05)";
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      if (levelUpFlashTimer > 0) {
        const alpha = Math.max(0, levelUpFlashTimer / 600) * 0.6;
        ctx.save();
        ctx.fillStyle = `rgba(129,140,248,${alpha})`;
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }

      playerTrail.forEach(t => {
        const alpha = Math.max(0, t.life / 200);
        ctx.save();
        ctx.globalAlpha = alpha * 0.5;
        ctx.fillStyle = "#00FFF0";
        ctx.fillRect(t.x, t.y, t.width, t.height);
        ctx.restore();
      });

      ctx.save();
      ctx.shadowColor = shieldActive ? "#34d399" : "#00FFF0";
      ctx.shadowBlur = shieldActive ? 22 : 18;

      ctx.fillStyle = shieldActive ? "#34d399" : "#00FFF0";
      ctx.fillRect(player.x, player.y, player.width, player.height);

      ctx.shadowBlur = 0;
      ctx.strokeStyle = "rgba(15,23,42,0.9)";
      ctx.lineWidth = 2;
      ctx.strokeRect(
        player.x + 1,
        player.y + 1,
        player.width - 2,
        player.height - 2
      );

      ctx.restore();

      const neonColors = {
        normal: "#00FFF0",
        gold: "#FFE600",
        danger: "#FF3B30"
      };

      obstacles.forEach((o) => {
        const color = neonColors[o.type] || "#00FFF0";

        ctx.save();
        ctx.shadowColor = color;
        ctx.shadowBlur = 14;

        ctx.fillStyle = color;
        ctx.fillRect(o.x, o.y, o.width, o.height);

        ctx.shadowBlur = 0;
        ctx.strokeStyle = "rgba(15,23,42,0.9)";
        ctx.lineWidth = 2;
        ctx.strokeRect(o.x + 1, o.y + 1, o.width - 2, o.height - 2);

        ctx.restore();
      });

      // Power-ups (visuales)
      powerups.forEach(p => {
        const isSlow = p.type === "slow";
        const baseColor = isSlow ? "#38bdf8" : "#34d399";
        const label = isSlow ? "‚è±" : "üõ°";
        const cx = p.x + p.width / 2;
        const cy = p.y + p.height / 2;
        const radius = p.width / 2;

        ctx.save();

        ctx.shadowColor = baseColor;
        ctx.shadowBlur = 18;

        ctx.beginPath();
        ctx.arc(cx, cy, radius, 0, Math.PI * 2);
        ctx.fillStyle = baseColor;
        ctx.fill();

        ctx.shadowBlur = 0;
        ctx.lineWidth = 3;
        ctx.strokeStyle = "rgba(15,23,42,0.9)";
        ctx.stroke();

        ctx.fillStyle = "#0f172a";
        ctx.font = "20px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(label, cx, cy + 1);

        ctx.restore();
      });

      particles.forEach(p => {
        const alpha = Math.max(0, p.life / 500);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      });

      streaks.forEach(s => {
        const alpha = Math.max(0, s.life / 200);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.strokeStyle = "#ffffff";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(s.x, s.y);
        ctx.lineTo(s.x, s.y + 18);
        ctx.stroke();
        ctx.restore();
      });

      comboTexts.forEach(t => {
        const alpha = Math.max(0, t.life / 800);
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = t.color || "#e5e7eb";
        ctx.font = "18px system-ui";
        ctx.textAlign = "center";
        ctx.fillText(t.text, t.x, t.y);
        ctx.restore();
      });

      ctx.fillStyle = "#fff";
      ctx.font = "20px system-ui";
      ctx.textAlign = "left";
      ctx.fillText("Puntaje: " + Math.floor(score), 20, 30);
      ctx.fillText("Mejor: " + Math.floor(bestScore), 20, 55);
      ctx.fillText("Combo: " + combo + " (Mejor: " + bestCombo + ")", 20, 80);
      ctx.fillText("Nivel: " + level, 20, 105);

      const blinkSlow =
        slowMotionActive && slowMotionTimer <= 1200;
      const blinkShield =
        shieldActive && shieldTimer <= 1500;

      if (hardcoreActive) {
        ctx.save();
        ctx.fillStyle = "#f97316";
        ctx.font = "18px system-ui";
        ctx.textAlign = "right";
        ctx.fillText("HARDCORE", canvas.width - 20, 30);
        ctx.restore();
      }

      if (slowMotionActive) {
        let alpha = 1;
        if (blinkSlow) {
          alpha = 0.4 + 0.6 * Math.abs(Math.sin((lastTime || 0) / 160));
        }
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "#38bdf8";
        ctx.font = "16px system-ui";
        ctx.textAlign = "right";
        ctx.fillText("SLOW", canvas.width - 20, 55);
        ctx.restore();
      }

      if (shieldActive) {
        let alpha = 1;
        if (blinkShield) {
          alpha = 0.4 + 0.6 * Math.abs(Math.sin((lastTime || 0) / 160));
        }
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = "#34d399";
        ctx.font = "16px system-ui";
        ctx.textAlign = "right";
        ctx.fillText("ESCUDO", canvas.width - 20, 80);
        ctx.restore();
      }

      if (isGameOver) {
        ctx.fillStyle = "rgba(0,0,0,0.6)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.fillStyle = "#fff";
        ctx.font = "32px system-ui";
        ctx.textAlign = "center";
        ctx.fillText("üíÄ GAME OVER üíÄ", canvas.width / 2, canvas.height / 2 - 30);

        ctx.font = "20px system-ui";
        ctx.fillText(
          "Puntaje final: " + Math.floor(score),
          canvas.width / 2,
          canvas.height / 2 + 5
        );
        ctx.fillText(
          "Mejor puntaje: " + Math.floor(bestScore),
          canvas.width / 2,
          canvas.height / 2 + 35
        );
        ctx.fillText(
          "Pulsa ESPACIO para reiniciar",
          canvas.width / 2,
          canvas.height / 2 + 65
        );
      }

      ctx.restore();
    }

    function gameLoop(timestamp) {
      if (!lastTime) lastTime = timestamp;
      const deltaTime = timestamp - lastTime;
      lastTime = timestamp;

      update(deltaTime);
      draw();

      requestAnimationFrame(gameLoop);
    }

    requestAnimationFrame(gameLoop);
  </script>
</body>

</html>